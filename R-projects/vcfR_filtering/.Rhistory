library(praise)
praise()
#CH 1: Reading in Data----
VCF <- read_tsv("data/all_Copy.VCF")
#CH 0: Libraries ----
library(dplyr)
library(ggplot2)
library(readr)
library(stringr)
library(lubridate)
library(tidyr)
library(forcats)
library(praise)
library(purrr)
#CH 1: Reading in Data----
VCF <- read_tsv("data/all_Copy.VCF")
View(VCF)
#CH 2: Making it longer and good formatted----
VCF_Longer <- VCF %>% #makes it longer
select(!(KOC14_LN2)) %>% #we kill this sample, its too asinine to deal with, and this has been the standard practice
pivot_longer(names_to="SAMPLE",values_to="CODING",cols=starts_with(c("HUX","TMR","HHT","HRM","LLB","KOB","KOA","KOC","KOK", "KDN","KGL","BOK","STW","CRM","SCL","VSG")))
VCF_Longer <- VCF_Longer %>% #we encode a useful true false variable using the data provided
mutate(PRESENCE=case_when(
CODING=="./.:0:0,0,0,0" ~ FALSE,
TRUE ~ TRUE)
)
View(VCF_Longer)
VCF_Wider <- VCF_Longer %>%
mutate(SAMPLE_P=str_c(SAMPLE,"P",sep="_")) #This enables us to do the alpha/beta encoding split, duplicating the sample names with sample_P so that we can keep track of two different columns for each sample
VCF_Wider_alpha <- VCF_Wider %>%
select(!c(PRESENCE,SAMPLE_P)) %>%
pivot_wider(names_from=SAMPLE,values_from=CODING) #make a wider dataframe which has the original VCF encoding. I want to retain this in our dataframe so that, once I have filtered, I can just cut the fat and return to the VCF format as easily as possible
VCF_Wider_beta <- VCF_Wider %>%
select(!c(CODING,SAMPLE)) %>%
pivot_wider(names_from=SAMPLE_P,values_from=PRESENCE) #make a wider dataframe which has the true/false encoding that is more useful to me for filtration
VCF_Wider_full <- full_join(VCF_Wider_beta,VCF_Wider_alpha)
#CH 4: Encoding Variables ----
VCF_Wider_Data <- VCF_Wider_full %>% #Population Encoding
mutate(HUX_PRESENT = select(.,HUX01_P:HUX14_P)%>%rowSums(),#this is a genius way of doing this. We select all of the columns representing individuals in a single population we want since they are next to each other, this essentially creates an ephemeral dataframe, which can be rowsummed to make a single column. We set this to the mutate
TMR_PRESENT = select(.,TMR01_P:TMR14_P)%>%rowSums(), #I dont know why we need the . but we do
HHT_PRESENT = select(.,HHT01_P:HHT14_P)%>%rowSums(),
HRM_PRESENT = select(.,HRM01_P:HRM14_P)%>%rowSums(),
LLB_PRESENT = select(.,LLB01_P:LLB14_P)%>%rowSums(),
KOB_PRESENT = select(.,KOB01_P:KOB15_P)%>%rowSums(),
KOA_PRESENT = select(.,KOA01_P:KOA14_P)%>%rowSums(),
KOC_PRESENT = select(.,KOC01_P:KOC14_P)%>%rowSums(),
KOK_PRESENT = select(.,KOK01_P:KOK14_P)%>%rowSums(),
KDN_PRESENT = select(.,KDN01_P:KDN14_P)%>%rowSums(),
KGL_PRESENT = select(.,KGL01_P:KGL14_P)%>%rowSums(),
BOK_PRESENT = select(.,BOK01_P:BOK14_P)%>%rowSums(),
STW_PRESENT = select(.,STW01_P:STW14_P)%>%rowSums(),
CRM_PRESENT = select(.,CRM01_P:CRM14_P)%>%rowSums(),
SCL_PRESENT = select(.,SCL01_P:SCL14_P)%>%rowSums(),
VSG_PRESENT = select(.,VSG01_P:VSG14_P)%>%rowSums())
VCF_Wider_Data <- VCF_Wider_Data %>% #This does group encoding from the population encoding
mutate(HURON = select(.,HUX_PRESENT,TMR_PRESENT,HHT_PRESENT,HRM_PRESENT,LLB_PRESENT)%>%rowSums(),
KOKOSING = select(.,KOB_PRESENT,KOA_PRESENT,KOC_PRESENT,KOK_PRESENT,KDN_PRESENT,KGL_PRESENT)%>%rowSums(),
RUSTICUS = select(.,BOK_PRESENT,STW_PRESENT)%>%rowSums(),
SAMBORNI = select(.,CRM_PRESENT,SCL_PRESENT,VSG_PRESENT)%>%rowSums())
VCF_Wider_Data <- VCF_Wider_Data %>% #This is simply encoding a variable which sums all hits for a given locus
mutate(TOTAL=select(.,HURON:SAMBORNI)%>%rowSums())
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
#CH 5: Filtration for Loci----
#this should be a relatively simple affair. We will start with looking for loci that have 2 in each group
#first i will try and do it using the summary dataset, for ease of reading, nothing should change if i use the Data dataset, hopefully
Filtered_1 <- VCF_Summary %>%
filter(HURON>=2 & KOKOSING>=2 & RUSTICUS>=2 & SAMBORNI>=2)
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
#CH 5: Filtration for Loci----
#this should be a relatively simple affair. We will start with looking for loci that have 2 in each group
#first i will try and do it using the summary dataset, for ease of reading, nothing should change if i use the Data dataset, hopefully
Filtered_1 <- VCF_Summary %>%
filter(HURON>=2 & KOKOSING>=2 & RUSTICUS>=2 & SAMBORNI>=2)
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
#CH 5: Filtration for Loci----
#this should be a relatively simple affair. We will start with looking for loci that have 2 in each group
#first i will try and do it using the summary dataset, for ease of reading, nothing should change if i use the Data dataset, hopefully
Filtered_1 <- VCF_Summary %>%
filter(HURON>=2 & KOKOSING>=2 & RUSTICUS>=2 & SAMBORNI>=2)
View(VCF_Wider_Data)
praise()
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
#CH 5: Filtration for Loci----
#this should be a relatively simple affair. We will start with looking for loci that have 2 in each group
#first i will try and do it using the summary dataset, for ease of reading, nothing should change if i use the Data dataset, hopefully
Filtered_1 <- VCF_Summary %>%
filter(HURON>=2 & KOKOSING>=2 & RUSTICUS>=2 & SAMBORNI>=2)
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL) %>%
View(VCF_Summary)
VCF_Summary <- VCF_Wider_Data %>% #This is just a lil table which retains only the variables specifically needed for filtration (location, population encoding, as well as the total variable). It is simply nicer to look at when running filtrations but cannot be returned to the VCF format we need
select(`#CHROM`,POS,HUX_PRESENT:TOTAL)
View(VCF_Summary)
#first i will try and do it using the summary dataset, for ease of reading, nothing should change if i use the Data dataset, hopefully
Filtered_1 <- VCF_Summary %>%
filter(HURON>=2 & KOKOSING>=2 & RUSTICUS>=2 & SAMBORNI>=2)
Filtered_1 %>%
ggplot()+
geom_histogram(mapping=aes(x=TOTAL),bins=70) #hm. cool
#CH 1: Reading data ----
#reading is simple
VCF <- read.vcfR("data/all.vcf")
#CH 0: Libraries ----
library(dplyr)
library(ggplot2)
library(readr)
library(stringr)
library(lubridate)
library(tidyr)
library(forcats)
library(praise)
library(purrr)
library(vcfR)
#CH 1: Reading data ----
#reading is simple
VCF <- read.vcfR("data/all.vcf")
#now we convert to a tibble and hope that it doesnt break
VCF_tidy_all <- vcfR2tidy(VCF)
#this gives us a nicer tibble that has already been made longer for me
VCF_tidy <- VCF_tidy_all[["gt"]]
View(VCF_tidy)
#ok lets add a presence column
VCF_work <- VCF_tidy %>%
mutate(present=case_when(
gt_CATG=="0,0,0,0" ~ "absent",
.default = "present"
))
View(VCF_work)
#ok lets add a presence column
VCF_work <- VCF_tidy %>%
mutate(present=case_when(
gt_CATG=="0,0,0,0" ~ FALSE,
.default = TRUE
))
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration
VCF_work_w <- VCF_work %>%
mutate(Indiv_P=str_c(Indiv,"P",sep="_")) #This enables us to do the alpha/beta encoding split, duplicating the sample names with sample_P so that we can keep track of two different columns for each sample
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration
VCF_work_w <- VCF_work %>%
pivot_wider(names_from=Indiv,values_from=present)
View(VCF_work_w)
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration
VCF_work_w <- VCF_work %>%
pivot_wider(names_from=Indiv,values_from=present) %>%
mutate(index=row_number())
delete <- VCF_work_w %>%
filter(ChromKey==1)
View(delete)
delete <- VCF_work_w %>%
filter(ChromKey==1&POS==69)
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration. also adding an index column
VCF_work_w <- VCF_work %>%
select(c(ChromKey,POS,Inidv,present)) %>%
pivot_wider(names_from=Indiv,values_from=present) %>%
mutate(index=row_number())
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration. also adding an index column
VCF_work_w <- VCF_work %>%
select(c(ChromKey,POS,Indiv,present)) %>%
pivot_wider(names_from=Indiv,values_from=present) %>%
mutate(index=row_number())
remove(delete)
#CH 4: Encoding populations
#now we do the higher level population encoding
VCF_work_w <- VCF_work_w %>%
mutate(HUX_PRESENT = select(.,HUX01:HUX14)%>%rowSums(),#this is a genius way of doing this. We select all of the columns representing individuals in a single population we want since they are next to each other, this essentially creates an ephemeral dataframe, which can be rowsummed to make a single column. We set this to the mutate
TMR_PRESENT = select(.,TMR01:TMR14)%>%rowSums(), #I dont know why we need the . but we do
HHT_PRESENT = select(.,HHT01:HHT14)%>%rowSums(),
HRM_PRESENT = select(.,HRM01:HRM14)%>%rowSums(),
LLB_PRESENT = select(.,LLB01:LLB14)%>%rowSums(),
KOB_PRESENT = select(.,KOB01:KOB15)%>%rowSums(),
KOA_PRESENT = select(.,KOA01:KOA14)%>%rowSums(),
KOC_PRESENT = select(.,KOC01:KOC14)%>%rowSums(),
KOK_PRESENT = select(.,KOK01:KOK14)%>%rowSums(),
KDN_PRESENT = select(.,KDN01:KDN14)%>%rowSums(),
KGL_PRESENT = select(.,KGL01:KGL14)%>%rowSums(),
BOK_PRESENT = select(.,BOK01:BOK14)%>%rowSums(),
STW_PRESENT = select(.,STW01:STW14)%>%rowSums(),
CRM_PRESENT = select(.,CRM01:CRM14)%>%rowSums(),
SCL_PRESENT = select(.,SCL01:SCL14)%>%rowSums(),
VSG_PRESENT = select(.,VSG01:VSG14)%>%rowSums())
VCF_work_w <- VCF_work_w %>%
mutate(HURON = select(.,HUX_PRESENT,TMR_PRESENT,HHT_PRESENT,HRM_PRESENT,LLB_PRESENT)%>%rowSums(),
KOKOSING = select(.,KOB_PRESENT,KOA_PRESENT,KOC_PRESENT,KOK_PRESENT,KDN_PRESENT,KGL_PRESENT)%>%rowSums(),
RUSTICUS = select(.,BOK_PRESENT,STW_PRESENT)%>%rowSums(),
SAMBORNI = select(.,CRM_PRESENT,SCL_PRESENT,VSG_PRESENT)%>%rowSums())
VCF_work_w <- VCF_work_w %>%
mutate(TOTAL=select(.,HURON:SAMBORNI)%>%rowSums())
#making a table without the individuals
VCF_work_summary <- VCF_work_w %>%
select(ChromKey,POS,index:TOTAL)
#for now im just gonna do a pretty simple filtration
VCF_filtered <- VCF_work_summary %>%
filter(HURON>=5 & KOKOSING>=5 & RUSTICUS>=5 & SAMBORNI>=5)
gold <- pull(VCF_filtered,Index)
gold <- pull(VCF_filtered,index)
View(VCF)
#CH 6: VCF modification ----
VCF[gt]
VCF@gt
View(VCF@gt)
View(VCF@fix)
View(VCF)
#CH 6: VCF modification ----
VCF_modified <- VCF
VCF_mod_gt <- VCF_modified@gt
VCF_mod_fix <- VCF_modified@fix
VCF_mod_gt <- VCF@gt
VCF_mod_fix <- VCF@fix
View(VCF_mod_fix)
VCF_mod_gt <- VCF@gt[gold,]
VCF_mod_fix <- VCF@fix[gold,]
VCF_modified@gt <- VCF_mod_gt
VCF_modified@fix <- VCF_mod_fix
View(VCF_modified)
#i think that does it, now lets write this badboy
write.vcf(VCF_modified,"data/first_filter.vcf.gz")
#CH 0: Libraries ----
library(dplyr)
library(ggplot2)
#CH 0: Libraries ----
library(dplyr)
library(readr)
library(stringr)
library(lubridate)
#CH 0: Libraries ----
library(dplyr)
library(ggplot2)
library(readr)
library(stringr)
library(lubridate)
library(tidyr)
library(forcats)
library(praise)
library(purrr)
library(vcfR)
VCF <- read.vcfR("data/all.vcf")
#now we convert to a tibble and hope that it doesnt break
VCF_tidy_all <- vcfR2tidy(VCF)
#this tibble seems to have a lot of data that we dont need, i think i can jsut extract the stuff in this way
#this gives us a nicer tibble that has already been made longer for me
VCF_tidy <- VCF_tidy_all[["gt"]]
View(VCF_tidy)
View(VCF_tidy)
#now then lets not forget to remove KOC14_L2, and hope nothing breaks
VCF_tidy <- VCF_tidy %>%
filter(Indiv!="KOC14_LN2")
#CH2: encoding presence ----
#ok lets add a presence column
VCF_work <- VCF_tidy %>%
mutate(present=case_when(
gt_CATG=="0,0,0,0" ~ FALSE,
.default = TRUE
))
#now we wider by sample so that we can do some population based counting. we need these population numbers for filtration. also adding an index column
VCF_work_w <- VCF_work %>%
select(c(ChromKey,POS,Indiv,present)) %>%
pivot_wider(names_from=Indiv,values_from=present) %>%
mutate(index=row_number())
#CH 4: Encoding populations ----
#now we do the higher level population encoding
VCF_work_w <- VCF_work_w %>%
mutate(HUX_PRESENT = select(.,HUX01:HUX14)%>%rowSums(),#this is a genius way of doing this. We select all of the columns representing individuals in a single population we want since they are next to each other, this essentially creates an ephemeral dataframe, which can be rowsummed to make a single column. We set this to the mutate
TMR_PRESENT = select(.,TMR01:TMR14)%>%rowSums(), #I dont know why we need the . but we do
HHT_PRESENT = select(.,HHT01:HHT14)%>%rowSums(),
HRM_PRESENT = select(.,HRM01:HRM14)%>%rowSums(),
LLB_PRESENT = select(.,LLB01:LLB14)%>%rowSums(),
KOB_PRESENT = select(.,KOB01:KOB15)%>%rowSums(),
KOA_PRESENT = select(.,KOA01:KOA14)%>%rowSums(),
KOC_PRESENT = select(.,KOC01:KOC14)%>%rowSums(),
KOK_PRESENT = select(.,KOK01:KOK14)%>%rowSums(),
KDN_PRESENT = select(.,KDN01:KDN14)%>%rowSums(),
KGL_PRESENT = select(.,KGL01:KGL14)%>%rowSums(),
BOK_PRESENT = select(.,BOK01:BOK14)%>%rowSums(),
STW_PRESENT = select(.,STW01:STW14)%>%rowSums(),
CRM_PRESENT = select(.,CRM01:CRM14)%>%rowSums(),
SCL_PRESENT = select(.,SCL01:SCL14)%>%rowSums(),
VSG_PRESENT = select(.,VSG01:VSG14)%>%rowSums())
VCF_work_w <- VCF_work_w %>%
mutate(HURON = select(.,HUX_PRESENT,TMR_PRESENT,HHT_PRESENT,HRM_PRESENT,LLB_PRESENT)%>%rowSums(),
KOKOSING = select(.,KOB_PRESENT,KOA_PRESENT,KOC_PRESENT,KOK_PRESENT,KDN_PRESENT,KGL_PRESENT)%>%rowSums(),
RUSTICUS = select(.,BOK_PRESENT,STW_PRESENT)%>%rowSums(),
SAMBORNI = select(.,CRM_PRESENT,SCL_PRESENT,VSG_PRESENT)%>%rowSums())
VCF_work_w <- VCF_work_w %>%
mutate(TOTAL=select(.,HURON:SAMBORNI)%>%rowSums())
#making a table without the individuals
VCF_work_summary <- VCF_work_w %>%
select(ChromKey,POS,index:TOTAL)
#for now im just gonna do a pretty simple filtration
VCF_filtered <- VCF_work_summary %>%
filter(HURON>=5 & KOKOSING>=5 & RUSTICUS>=5 & SAMBORNI>=5)
#create a list which we can use to modify the original vcf
gold <- pull(VCF_filtered,index)
#CH 6: VCF modification ----
VCF_modified <- VCF
VCF_mod_gt <- VCF@gt[gold,]
VCF_mod_fix <- VCF@fix[gold,]
VCF_modified@gt <- VCF_mod_gt
VCF_modified@fix <- VCF_mod_fix
#i think that does it, now lets write this badboy
write.vcf(VCF_modified,"data/first_filter.vcf.gz")
